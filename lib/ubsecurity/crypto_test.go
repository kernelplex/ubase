package ubsecurity

import (
	"testing"
)

func TestEncryptionService(t *testing.T) {
	// Generate a random 32-byte key for testing
	key := GenerateSecureRandom(32)

	// Create encryption service
	service := CreateEncryptionService(key)

	// Test data
	testString := "This is a secret message!"
	testBytes := []byte(testString)

	t.Run("Encrypt/Decrypt roundtrip", func(t *testing.T) {
		// Test byte encryption
		encrypted, err := service.Encrypt(testBytes)
		if err != nil {
			t.Fatalf("Encrypt failed: %v", err)
		}

		decrypted, err := service.Decrypt(encrypted)
		if err != nil {
			t.Fatalf("Decrypt failed: %v", err)
		}

		if string(decrypted) != testString {
			t.Errorf("Decrypted data doesn't match original. Got %q, want %q", decrypted, testString)
		}
	})

	t.Run("Encrypt64/Decrypt64 roundtrip", func(t *testing.T) {
		// Test string encryption
		encrypted, err := service.Encrypt64(testString)
		if err != nil {
			t.Fatalf("Encrypt64 failed: %v", err)
		}

		decrypted, err := service.Decrypt64(encrypted)
		if err != nil {
			t.Fatalf("Decrypt64 failed: %v", err)
		}

		if string(decrypted) != testString {
			t.Errorf("Decrypted data doesn't match original. Got %q, want %q", decrypted, testString)
		}
	})

	t.Run("Invalid key size", func(t *testing.T) {
		// Test with invalid key size
		invalidKey := GenerateSecureRandom(17) // Not 16, 24 or 32 bytes
		invalidService := CreateEncryptionService(invalidKey)

		if invalidService != nil {
			t.Error("Expected nil service with invalid key size")
		}
	})

	t.Run("Tampered data", func(t *testing.T) {
		// Test with tampered encrypted data
		encrypted, err := service.Encrypt(testBytes)
		if err != nil {
			t.Fatalf("Encrypt failed: %v", err)
		}

		// Tamper with the data
		encrypted[0] ^= 0xFF

		_, err = service.Decrypt(encrypted)
		if err == nil {
			t.Error("Expected error with tampered data, got nil")
		}
	})

	t.Run("Empty input", func(t *testing.T) {
		// Test with empty input
		_, err := service.Encrypt([]byte{})
		if err != nil {
			t.Errorf("Encrypt with empty input failed: %v", err)
		}

		_, err = service.Encrypt64("")
		if err != nil {
			t.Errorf("Encrypt64 with empty input failed: %v", err)
		}
	})
}

func TestGenerateSecureRandom(t *testing.T) {
	t.Run("Valid length", func(t *testing.T) {
		length := uint32(32)
		bytes := GenerateSecureRandom(length)
		if len(bytes) != int(length) {
			t.Errorf("Generated bytes length mismatch. Got %d, want %d", len(bytes), length)
		}
	})

	t.Run("Zero length", func(t *testing.T) {
		bytes := GenerateSecureRandom(0)
		if len(bytes) != 0 {
			t.Errorf("Expected empty slice for zero length, got %d bytes", len(bytes))
		}
	})
}
