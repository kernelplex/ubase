package ubsecurity

import (
    "testing"
)

func TestEncryptionService(t *testing.T) {
	// Generate a random 32-byte key for testing
	key := GenerateSecureRandom(32)

	// Create encryption service
	service := NewEncryptionService(key)

	// Test data
	testString := "This is a secret message!"
	testBytes := []byte(testString)

	t.Run("Encrypt/Decrypt roundtrip", func(t *testing.T) {
		// Test byte encryption
		encrypted, err := service.Encrypt(testBytes)
		if err != nil {
			t.Fatalf("Encrypt failed: %v", err)
		}

		decrypted, err := service.Decrypt(encrypted)
		if err != nil {
			t.Fatalf("Decrypt failed: %v", err)
		}

		if string(decrypted) != testString {
			t.Errorf("Decrypted data doesn't match original. Got %q, want %q", decrypted, testString)
		}
	})

	t.Run("Encrypt64/Decrypt64 roundtrip", func(t *testing.T) {
		// Test string encryption
		encrypted, err := service.Encrypt64(testString)
		if err != nil {
			t.Fatalf("Encrypt64 failed: %v", err)
		}

		decrypted, err := service.Decrypt64(encrypted)
		if err != nil {
			t.Fatalf("Decrypt64 failed: %v", err)
		}

		if string(decrypted) != testString {
			t.Errorf("Decrypted data doesn't match original. Got %q, want %q", decrypted, testString)
		}
	})

    t.Run("Invalid key size panics", func(t *testing.T) {
        // NewEncryptionService panics on invalid key sizes
        defer func() {
            if r := recover(); r == nil {
                t.Fatal("expected panic for invalid key size, got none")
            }
        }()
        _ = NewEncryptionService(GenerateSecureRandom(17)) // Not 16, 24, or 32
    })

    t.Run("Tampered data", func(t *testing.T) {
		// Test with tampered encrypted data
		encrypted, err := service.Encrypt(testBytes)
		if err != nil {
			t.Fatalf("Encrypt failed: %v", err)
		}

		// Tamper with the data
		encrypted[0] ^= 0xFF

		_, err = service.Decrypt(encrypted)
		if err == nil {
			t.Error("Expected error with tampered data, got nil")
		}
    })

    t.Run("Empty input", func(t *testing.T) {
		// Test with empty input
		_, err := service.Encrypt([]byte{})
		if err != nil {
			t.Errorf("Encrypt with empty input failed: %v", err)
		}

		_, err = service.Encrypt64("")
		if err != nil {
			t.Errorf("Encrypt64 with empty input failed: %v", err)
		}
    })

    t.Run("Decrypt64 with invalid base64", func(t *testing.T) {
        _, err := service.Decrypt64("!!!not-base64!!!")
        if err == nil {
            t.Error("expected error for invalid base64 input, got nil")
        }
    })

    t.Run("Valid key sizes 16/24/32", func(t *testing.T) {
        sizes := []uint32{16, 24, 32}
        for _, sz := range sizes {
            key := GenerateSecureRandom(sz)
            // Expect no panic for valid sizes
            svc := NewEncryptionService(key)
            plaintext := []byte("hello")
            enc, err := svc.Encrypt(plaintext)
            if err != nil {
                t.Fatalf("encrypt failed for key size %d: %v", sz, err)
            }
            dec, err := svc.Decrypt(enc)
            if err != nil {
                t.Fatalf("decrypt failed for key size %d: %v", sz, err)
            }
            if string(dec) != string(plaintext) {
                t.Fatalf("roundtrip mismatch for key size %d", sz)
            }
        }
    })
}

func TestGenerateSecureRandom(t *testing.T) {
	t.Run("Valid length", func(t *testing.T) {
		length := uint32(32)
		bytes := GenerateSecureRandom(length)
		if len(bytes) != int(length) {
			t.Errorf("Generated bytes length mismatch. Got %d, want %d", len(bytes), length)
		}
	})

	t.Run("Zero length", func(t *testing.T) {
		bytes := GenerateSecureRandom(0)
		if len(bytes) != 0 {
			t.Errorf("Expected empty slice for zero length, got %d bytes", len(bytes))
		}
	})
}

func TestGenerateSecureRandomString(t *testing.T) {
    t.Run("Default charset length and chars", func(t *testing.T) {
        const n = 64
        s := GenerateSecureRandomString(n)
        if len(s) != n {
            t.Fatalf("expected length %d, got %d", n, len(s))
        }
        allowed := map[rune]bool{}
        for _, r := range []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") {
            allowed[r] = true
        }
        for _, r := range []rune(s) {
            if !allowed[r] {
                t.Fatalf("unexpected rune %q in output", r)
            }
        }
    })

    t.Run("Custom charset length and chars", func(t *testing.T) {
        const n = 48
        chars := []rune("aBc123")
        s := GenerateSecureRandomStringWithChars(n, chars)
        if len(s) != n {
            t.Fatalf("expected length %d, got %d", n, len(s))
        }
        allowed := map[rune]bool{}
        for _, r := range chars {
            allowed[r] = true
        }
        for _, r := range []rune(s) {
            if !allowed[r] {
                t.Fatalf("unexpected rune %q in output", r)
            }
        }
    })
}
